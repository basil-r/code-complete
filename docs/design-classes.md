### Класи

#### Рекомендації щодо хорошої абстракції

Інтерфейс класу повинен бути хорошою абстракцією, яка приховує деталі його реалізації. Всі методи інтерфейсу повинні служити єдиній узгодженій цілі.

Класи – механізми реалізації абстрактних типів даних. Кожен клас має бути реалізацією лише одного АТД (набір даних і методів, що служать одній меті).

Під час розробки класу перевірте кожний загальнодоступний метод, щоб побачити, чи потрібний вам його протилежний варіант.

Якщо одні методи класу працюють з однією половиною даних, а інші з іншою, то розділіть їх на два класи.

Якщо робота методу залежить від параметра, який необхідно ініціалізувати заздалегідь; або метод потрібно викликати перед іншим - тоді використовуйте _assertions_.

Змінюючи та розширюючи клас, знайдіть спосіб внести зміни, які забезпечують узгодженість абстракції.

Клас, який представляє хорошу абстракцію, зазвичай характеризується _high cohesion_.

#### Рекомендації щодо хорошої інкапсуляції

Якщо розкриття методу відповідає абстракції, зробіть його загальнодоступним, інакше приховайте.

Не робіть атрибути (властивості) класу відкритими:

```javascript
// bad
class Point {
  x;
  y;
}
```

> З будь-якого місця програми можна змінити властивості об'єкта, клас нічого не знатиме. Також тут розкрито деталі реалізації властивостей об'єкта.

```javascript
// good
class Point {
  #x;
  #y;

  get x() {
    return this.#x;
  }

  set x(value) {
    this.#x = value;
  }

  // or
  getY() {
    return this.#y;
  }

  setY(value) {
    this.#y = value;
  }
}
```

> Тут приховані деталі реалізації даних. Властивості об’єкта можуть бути або строками, або зберігатися в певній структурі даних, про яку користувач цього класу не буде знати.

Клас повинен дотримуватися контракту, сформульованого за допомогою інтерфейсу. Висловлюючи свої вимоги в інтерфейсі, клас не повинен робити припущень про те, як цей інтерфейс використовуватиметься чи не використовуватиметься.

Щоб зрозуміти, як використовувати клас, має бути достатньо документації інтерфейсу, а не перегляду його реалізації.

###### Неочевидні приклади порушення інкапсуляції

```javascript
class A {
  init() {}
  operate() {
    if (!this.#initialized) this.init();
    // ...
  }
}

// bad
instance.operate();

// good
instance.init();
instance.operate();
```

```javascript
class B {
  // ...
  async retrieve(db) {
    if (!db.isConnected()) await db.connect();
    return await db.getB();
  }
}

// bad
const data = await b.retrieve(db);

// good
await db.connect();
const data = await b.retrieve(db);
```

```javascript
// module A
const MAX_CONNECTION = 100;
export { MAX_CONNECTION };

// module B
const MAX_ROWS_SIZE = 100;
export { MAX_ROWS_SIZE };

class Sheets {
  // ...
}

// bad
sheets.setRows(MAX_CONNECTION);

// good
sheets.setRows(MAX_ROWS_SIZE);
```

Робіть дані базового класу закритими, а не захищеними.

Стережіться _high coupling_

#### Рекомендації щодо реалізації

Надайте перевагу відношенню "містить".

Якщо клас містить 9 елементів примітивного типу або 5 складних об’єктів, розділіть його на кілька менших класів.

Якщо один клас є більш спеціалізованим варіантом іншого класу, реалізуйте відношення - "є".

Проектуйте та документуйте класи з урахуванням можливості наслідування або забороніть його.

Дотримуйтесь принципу підстановки Лісков (**Liskov Substitution Principle, LSP**). Наслідування слід використовувати лише в тому випадку, якщо похідний клас дійсно "є" більш спеціалізованою версією базового класу. Клієнти повинні мати можливість використання підкласів через інтерфейс базового класу, не помічаючи жодних відмінностей. Всі методи базового класу повинні мати однакове значення в кожному похідному класі.

Не застосовуйте наслідування, якщо:

- інтерфейс потрібний, а реалізація не важлива;

  ```javascript
  class Base {
    #a;
    #b;

    action() {
      return this.#a + this.#b;
    }
  }

  class One extends Base {
    #c;

    action() {
      return this.#c ** 2;
    }
  }
  ```

- потрібна реалізація, а інтерфейс не важливий.

  ```javascript
  class Base {
    action(value) {
      return value.map((item) => item ** 2);
    }

    otherBaseAction() {
      // ...
    }
  }

  // bad
  class One extends Base {
    secondAction(value) {
      return super.action(value);
    }
  }

  const one = new One();
  one.secondAction(list);
  // one.otherBaseAction() will never be used

  // good
  class One {
    constructor(baseInstance) {
      super();
      this.member = baseInstance;
    }

    secondAction(value) {
      return this.member.action(value);
    }
  }

  const one = new One();
  one.secondAction(list);
  ```

Не використовуйте імена неперевизначуваних методів базового класу у похідних класах.

Перемістіть загальні інтерфейси, дані та поведінку якомога вище в ієрархії наслідування.

Немає сенсу в наслідуванні, якщо базовий клас матиме лише один похідний клас.

Уникайте похідних класів, які перевизначають метод базового класу, залишаючи його порожнім.

Уникайте багаторівневих ієрархій наслідування. Допустимі два,максимум три рівні.

Якщо це доречно – віддайте перевагу поліморфізму.

Робіть усі дані-властивості закритими, а не захищеними. Якщо похідний клас дійсно потребує доступу до атрибутів базового класу, додайте захищені методи доступу до базового класу.

Якщо декілька класів мають загальні дані, але не форми поведінки, створіть загальний об'єкт, який можна було б включити у всі ці класи.

Якщо кілька класів мають загальні форми поведінки, але не дані, зробіть ці класи похідними від загального базового класу, що визначає загальні методи.

Якщо кілька класів мають загальні дані та форми поведінки, зробіть ці класи похідними від загального базового класу, що визначає загальні дані та методи.

Включайте в клас якнайменше методів. А кількість методів, що викликатиметься екземпляром класу - мінімізуйте.

Блокуйте неявно згенеровані компілятором методи та оператори, які вам не потрібні (приватний конструктор).

Дотримуйтеся [правила Деметри](https://en.wikipedia.org/wiki/Law_of_Demeter).

> Метод об'єкта А має викликати методи тільки наступних типів об'єктів:
>
> 1. власне самого об'єкта А;
> 2. параметрів методу;
> 3. будь-яких об'єктів, створених у межах методу;
> 4. прямих компонентних об'єктів об'єкта А;
> 5. глобальних змінних, доступних об'єкту А, у межах методу.

Мінімізуйте співпрацю класу з іншими класами.

Ініціалізуйте по можливості всі дані-члени у всіх кострукторах.

Створюйте класи-одинаки за допомогою закритого конструктора.

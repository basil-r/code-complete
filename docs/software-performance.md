### Продуктивність

Продуктивність лише опосередковано пов'язана зі швидкістю коду.

Користувачів більше цікавлять явні характеристики програми, ніж якість коду.  
Для користувачів важливіше кількість інформації, яку програма дозволяє обробити за певний період часу, а також такі фактори, як своєчасне отримання програми, зрозумілий інтерфейс користувача та запобігання простоїв.

Прагнення до кращої швидкодії може зменшити загальну продуктивність програми, а не покращити її.

Слід покращувати швидкодію чи обсяг програми не лише на рівні коду, але й у контексті:

- вимог до проекту - зміна вимог щодо показників;
- проекту програми - розробка архітектури з метою досягення намічених показників;
- проектів класів та методів - вибір ефективних алгоритмів, структур даних;
- взаємодії програми з ОС - читання файлу частинами (потоки);
- компіляції коду - оновлення віртуальної машини, нова версія платформи, новий компілятор;
- обладнання - відмова від підтримки застарілих пристроїв (барузерів);

#### Оптимізація коду

> Оптимізацією коду (**code tuning**) називають зміну коректного коду, спрямоване на підвищення його ефективності. Це внесення невеликих змін, які стосуються одного класу, одного методу, а найчастіше – кілька рядків коду.

> Менше 4% коду зазвичай відповідає більше 50% часу виконання програми. Доведіть роботу до кінця і лише потім удосконалюйтесь. Частина, яку слід довести до досконалості, зазвичай невелика.

##### Міфи оптимізації:

- Зменшення кількості рядків коду високого рівня покращує продуктивність або зменшує кількість кінцевого машинного коду;
- Оптимізацію слід проводити під час написання коду;
- Швидкодія програми не менш важлива, ніж її коректність.

##### Коли оптимізувати?

Створіть якісний проект. Переконайтеся, що програма правильна. Зробіть програму модульною та змінною, щоб з нею було легко працювати пізніше. Написавши правильну програму, оцініть її продуктивність (_профілювання_). Якщо програма громіздка, зробіть її швидкою та компактною. Не оптимізуйте код програми, доки не переконаєтеся, що вам справді це потрібно.

#### Причини зниження ефективності

- **Операції I/O**. Якщо обсяг використовуваної пам’яті не має великого значення, працюйте з даними в пам’яті, а не звертайтеся до диска, бази даних або мережевого ресурсу.
- **Операція, яка змушує ОС міняти [сторінки пам’яті](https://en.wikipedia.org/wiki/Memory_paging)**.
- **Виклики системних методів**. Вони часто включають [перемикання контексту](https://en.wikipedia.org/wiki/Context_switch) (методи роботи з диском, клавіатурою, монітором, принтером та іншими пристроями, методи управління пам'яттю і деякі допоміжні методи).
- **Помилки** - таблиця БД без індекса, до якої часто звертаються; постійні спроби (аж до ліміту) опитування неіснуючого ресурсу.

#### Методи оптимізації коду

##### Логічні операції

- Припинення перевірки умови відразу після отримання відповіді

  ```javascript
  const includesBook = (goods) => {
    for (const product of goods) {
      if (product.name === "book") {
        return true;
      }
    }
  };
  ```

- Упорядкування тестів за частотою

  ```javascript
  // the probability that the required type of product is already in stock is high
  if (exists || willBeDelivered) {
    // ...
  }

  // the most frequent at the top
  switch (action) {
    case "order":
      doOrder();
      break;
    case "cancel":
      doCancel();
      break;
    // ...
  }
  ```

- Заміна складних виразів доступом до таблиці

  ```javascript
  // less effective

  let x = true; // 1
  let y = false; // 0
  let z = false; // 0

  let type;

  if ((x && y && z) || (!x && !y && !z)) {
    type = "one";
  } else if ((x && y && !z) || (!x && !y && z)) {
    type = "two";
  } else if ((x && !y && z) || (!x && y && !z)) {
    type = "three";
  } else if ((x && !y && !z) || (!x && y && z)) {
    type = "four";
  }

  // type is "four"

  // more effective

  let typeTable = [
    [
      ["one", "two"],
      ["three", "four"],
    ],
    [
      ["four", "three"],
      ["two", "one"],
    ],
  ];

  let x = true; // 1
  let y = false; // 0
  let z = false; // 0

  // type is "four"
  const type = typeTable[+x][+y][+z];
  ```

##### Цикли

- Розмикання циклу

  > Замиканням (_switching_) циклу називають ухвалення рішення всередині циклу при кожній його ітерації. Якщо під час виконання циклу рішення не змінюється, ви можете розімкнути (_unswitch_) цикл, прийнявши рішення поза циклом.

  ```javascript
  // less effective
  for (let i = 0; i < count; i++) {
    if (shapeType === types.square) {
      drawSquare();
    } else {
      drawTriangle();
    }
  }

  // more effective
  if (shapeType === types.square) {
    for (let i = 0; i < count; i++) {
      drawSquare();
    }
  } else {
    for (let i = 0; i < count; i++) {
      drawTriangle();
    }
  }
  ```

- Об'єднання циклів (jamming)

  ```javascript
  // less effective
  for (let i = 0; i < items.length; i++) {
    items[i].name = "";
  }
  for (let i = 0; i < items.length; i++) {
    items[i].price = 0;
  }

  // more effective
  for (let i = 0; i < items.length; i++) {
    items[i].name = "";
    items[i].price = 0;
  }
  ```

- Розгортання (unrolling) циклу

  > скорочення витрат, пов'язаних із виконанням циклу

  ```javascript
  // less effective

  const count = 10;
  const nums = [];

  for (let i = 0; i < count; i++) {
    nums.push(i ** 2);
  }

  // more effective

  const nums = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81];
  ```

- Мінімізація обсягу роботи, що виконується всередині циклів

  ```javascript
  const discount = {
    normal: {
      percent: 0.1,
      days: [2, 4],
    },
    advanced: {
      percent: 0.15,
      days: [1, 3],
    },
  };

  const getRate = (day, discount) => {
    const { normal, advanced } = discount;
    if (normal.days.includes(day)) return normal.percent;
    if (advanced.days.includes(day)) return advanced.percent;
    return 0;
  };

  const items = [100, 150, 200, 150, 100];
  const prices = Array(items.length);

  const day = new Date().getDay();

  // less effecive

  for (let i = 0; i < prices.length; i++) {
    prices[i] = items[i] - items[i] * getRate(day, discount);
  }

  // more effecive

  const factor = getRate(day, discount);

  for (let i = 0; i < prices.length; i++) {
    prices[i] = items[i] - items[i] * factor;
  }
  ```

- Вкладення більш ресурсомісткого циклу до менш ресурсомісткого

  ```javascript
  const table = [
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
    [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],
    [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],
    [41, 42, 43, 44, 45, 46, 47, 48, 49, 50],
  ];

  const row = table.length;
  const column = table[0].length;

  let total = 0;

  // less effective
  // 10 + 10 * 5 = 60 iterations

  for (let j = 0; j < column; j++) {
    for (let i = 0; i < row; i++) {
      total += table[i][j];
    }
  }

  // more effective
  // 5 + 5 * 10 = 55 iterations

  for (let i = 0; i < row; i++) {
    for (let j = 0; j < column; j++) {
      total += table[i][j];
    }
  }
  ```

- Зниження вартості операцій
  > заміну дорогої операції на дешевшу
